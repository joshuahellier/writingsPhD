\chapter{Code Listings}

\section{1d Ising Correlation Functions \label{sec:corrFnCode} }

This \texttt{Python} script computes the probability of a site being occupied $l$ lattice spacings away from an occupied site.
It requires the system size $L$ and the number of particles $N$ as inputs. The output is saved in a file called \texttt{corrFnResults.m}, which is formatted so that it may be used by \texttt{Mathematica}.

\begin{lstlisting}[language=Python]
import copy
import sys

def configMake(L, N, prevList, totList):
    if L==1:
        endList = [copy.deepcopy(prevList), N]
        totList.append(unfold(endList))
        return [N]
    if N==0:
       return configMake(L-1, 0, [copy.deepcopy(prevList), 0], totList)
    if L==N:
        return configMake(L-1, N-1, [copy.deepcopy(prevList), 1], totList)
    return [configMake(L-1, N, [copy.deepcopy(prevList), 0], totList),
    configMake(L-1, N-1, [copy.deepcopy(prevList), 1], totList)]

def adjSum(candList):
    listLen = len(candList)
    total = 0
    for index in range(0, listLen):
        total += candList[index-1]*candList[index]
    return total

def unfold(candList):
    if isinstance(candList, list):
        if len(candList)==2:
            return unfold(candList[0])+unfold(candList[1])
        if len(candList)==1:
            return candList
        if len(candList)==0:
            return []
    return [candList]

def listCollate(candList):
    maxItem = 0
    for index in candList:
        if index > maxItem:
            maxItem = index
    outPut = []
    for size in range(0, maxItem+1):
        numCounts = 0
        for index in candList:
            if index == size:
                numCounts += 1
        outPut.append((size, numCounts))
    return outPut

def genCorrFn(L, N):
    totList = []
    allStates = configMake(L, N, [], totList)
    restStates = []
    weightList = []
    maxAdj = 0
    for state in totList:
        if state[0]==1:
            restStates.append((state, adjSum(state)))
            if restStates[-1][1]>maxAdj:
                maxAdj = restStates[-1][1]
            weightList.append(restStates[-1][1])
    partFnList = listCollate(weightList)
    print(partFnList)
    partitionFn = "("
    for pair in partFnList:
        partitionFn += str(pair[1])+" Exp["+str(pair[0]-maxAdj)+"b] + "
    partitionFn += "0)"
    print(partitionFn)
    finalOut = "{"
    for shift in range(0, L-L/2):
        tempList = []
        for config in restStates:
            if config[0][shift] == 1:
                tempList.append(config[1])
        stateDist = listCollate(tempList)
        outSum = "{"+str(shift)+", ("
        for pair in stateDist:
            outSum += str(pair[1])+" Exp["+str(pair[0]-maxAdj)+"b] + "
        outSum += "0)/"+partitionFn+"}"
        finalOut += outSum
        if shift != L-L/2-1:
            finalOut += ", "
    finalOut+="}"
    return finalOut

L = int(sys.argv[1])

with open("corrFnResults.m", 'w') as f:
    f.write("{")
    for n in range(2, L-2):
        f.write("{"+str(n)+"/"+str(L)+", "+genCorrFn(L, n)+"}, ")
    f.write(genCorrFn(L, L-2) + "}")
\end{lstlisting}

\section{$n$-Dimensional Continuum-Limit MFT \label{sec:mftCode}}

This Mathematica script computes the current which flows between two adjacent sites
(offset in the $e_1$ direction) in the MFT of the $n$-dimensional SPM; due to symmetry, this tells us
what happens in an arbitrary direction. In this case $n$ is set to $3$,
but it still works if changed to any positive number.

\begin{lstlisting}[language=Mathematica]
n = 3;
i = 1;
zero = 0*UnitVector[n, 1];
e[i_] := UnitVector[n, i];
Hess = Table[
   Piecewise[{{d2p[j, i], j > i}}, d2p[i, j]], {i, 1, n}, {j, 1, n}];
Jacob = Table[dp[i], {i, 1, n}];
p[x_] := p0 + Jacob.x + 1/2 x.(Hess.x);
rightJ = 1/
    t0 (1 - p[1/2 a e[i]]) p[-(1/2) a e[i]] (1 - 
     z p[-(3/2) a e[i]]) Product[
    Piecewise[{{(1 - z p[-a e[j] - 1/2 a e[i]]) (1 - 
          z p[a e[j] - 1/2 a e[i]]), j != i}}, 1], {j, 1, n}];
leftJ = 1/t0 (1 - p[-(1/2) a e[i]]) p[
    1/2 a e[i]] (1 - z p[3/2 a e[i]]) Product[
    Piecewise[{{(1 - z p[-a e[j] + 1/2 a e[i]]) (1 - 
          z p[a e[j] + 1/2 a e[i]]), j != i}}, 1], {j, 1, n}];
fullJ = rightJ - leftJ + O[a]^3;
FullSimplify[fullJ]
\end{lstlisting}


